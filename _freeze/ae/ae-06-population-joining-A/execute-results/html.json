{
  "hash": "c491b4594e79ea0eb3fcd217c6050e1b",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"AE 06: Joining country populations with continents\"\nsubtitle: \"Suggested answers\"\ncategories: \n  - Application exercise\n  - Answers\n---\n\n\n::: callout-important\nThese are suggested answers.\nThis document should be used as reference only, it's not designed to be an exhaustive key.\n:::\n\n## Goal\n\nOur ultimate goal in this application exercise is to create a bar plot of total populations of continents, where the input data are:\n\n1.  Countries and populations\n2.  Countries and continents\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse) # for data wrangling and visualization\nlibrary(scales)    # for pretty axis breaks\n```\n:::\n\n\n## Data\n\n### Countries and populations\n\nThese data come from [The World Bank](https://data.worldbank.org/indicator/SP.POP.TOTL) and reflect population counts as of 2022.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npopulation <- read_csv(\"https://sta199-s24.github.io/data/world-pop-2022.csv\")\n```\n:::\n\n\nLet's take a look at the data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npopulation\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 217 × 3\n   country              year population\n   <chr>               <dbl>      <dbl>\n 1 Afghanistan          2022    41129. \n 2 Albania              2022     2778. \n 3 Algeria              2022    44903. \n 4 American Samoa       2022       44.3\n 5 Andorra              2022       79.8\n 6 Angola               2022    35589. \n 7 Antigua and Barbuda  2022       93.8\n 8 Argentina            2022    46235. \n 9 Armenia              2022     2780. \n10 Aruba                2022      106. \n# ℹ 207 more rows\n```\n\n\n:::\n:::\n\n\n### Continents\n\nThese data come from [Our World in Data](https://ourworldindata.org/grapher/continents-according-to-our-world-in-data).\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncontinents <- read_csv(\"https://sta199-s24.github.io/data/continents.csv\")\n```\n:::\n\n\nLet's take a look at the data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncontinents\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 285 × 4\n   entity                code      year continent    \n   <chr>                 <chr>    <dbl> <chr>        \n 1 Abkhazia              OWID_ABK  2015 Asia         \n 2 Afghanistan           AFG       2015 Asia         \n 3 Akrotiri and Dhekelia OWID_AKD  2015 Asia         \n 4 Aland Islands         ALA       2015 Europe       \n 5 Albania               ALB       2015 Europe       \n 6 Algeria               DZA       2015 Africa       \n 7 American Samoa        ASM       2015 Oceania      \n 8 Andorra               AND       2015 Europe       \n 9 Angola                AGO       2015 Africa       \n10 Anguilla              AIA       2015 North America\n# ℹ 275 more rows\n```\n\n\n:::\n:::\n\n\n## Exercises\n\n-   **Think out loud:**\n\n    -   Which variable(s) will we use to join the `population` and `continents` data frames?\n\n    `country` from `population` and `entity` from `continents`\n\n    -   We want to create a new data frame that keeps all rows and columns from `population` and brings in the corresponding information from `continents`. Which join function should we use?\n\n    `left_join()` with `population` on the left.\n\n-   **Demo:** Join the two data frames and name assign the joined data frame to a new data frame `population_continents`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npopulation_continent <- population |>\n  left_join(continents, by = join_by(country == entity))\n```\n:::\n\n\n-   **Demo:** Take a look at the newly created `population_continent` data frame. There are some countries that were not in `continents`. First, identify which countries these are (they will have `NA` values for `continent`).\n\n\n::: {.cell}\n\n```{.r .cell-code}\npopulation_continent |>\n  filter(is.na(continent))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 6\n  country                   year.x population code  year.y continent\n  <chr>                      <dbl>      <dbl> <chr>  <dbl> <chr>    \n1 Congo, Dem. Rep.            2022     99010. <NA>      NA <NA>     \n2 Congo, Rep.                 2022      5970. <NA>      NA <NA>     \n3 Hong Kong SAR, China        2022      7346. <NA>      NA <NA>     \n4 Korea, Dem. People's Rep.   2022     26069. <NA>      NA <NA>     \n5 Korea, Rep.                 2022     51628. <NA>      NA <NA>     \n6 Kyrgyz Republic             2022      6975. <NA>      NA <NA>     \n```\n\n\n:::\n:::\n\n\n-   **Demo:** All of these countries are actually in the `continents` data frame, but under different names. So, let's clean that data first by updating the country names in the `population` data frame in a way they will match the `continents` data frame, and then joining them, using a `case_when()` statement in `mutate()`. At the end, check that all countries now have continent information.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npopulation_continent <- population |>\n  mutate(country = case_when(\n    country == \"Congo, Dem. Rep.\" ~ \"Democratic Republic of Congo\",\n    country == \"Congo, Rep.\" ~ \"Congo\",\n    country == \"Hong Kong SAR, China\" ~ \"Hong Kong\",\n    country == \"Korea, Dem. People's Rep.\" ~ \"North Korea\",\n    country == \"Korea, Rep.\" ~ \"South Korea\",\n    country == \"Kyrgyz Republic\" ~ \"Kyrgyzstan\",\n    .default = country\n    )\n  ) |>\n  left_join(continents, by = join_by(country == entity))\n\npopulation_continent |>\n  filter(is.na(continent))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 0 × 6\n# ℹ 6 variables: country <chr>, year.x <dbl>, population <dbl>, code <chr>,\n#   year.y <dbl>, continent <chr>\n```\n\n\n:::\n:::\n\n\n-   **Think out loud:** Which continent do you think has the highest population? Which do you think has the second highest? The lowest?\n\nAdd your response here.\n\n-   **Demo:** Create a new data frame called `population_summary` that contains a row for each continent and a column for the total population for that continent, in descending order of population. Note that the function for calculating totals in R is `sum()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npopulation_summary <- population_continent |>\n  group_by(continent) |>\n  summarize(total_pop = sum(population)) |>\n  arrange(desc(total_pop))\n```\n:::\n\n\n-   **Your turn:** Make a bar plot with total population on the y-axis and continent on the x-axis, where the height of each bar represents the total population in that continent.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(population_summary, aes(x = continent, y = total_pop)) +\n  geom_col()\n```\n\n::: {.cell-output-display}\n![](ae-06-population-joining-A_files/figure-html/population-summary-bar-1.png){width=672}\n:::\n:::\n\n\n-   **Your turn:** Recreate the following plot, which is commonly referred to as a **lollipop plot**. Hint: Start with the points, then try adding the `segment`s, then add axis labels and `caption`, and finally, as a stretch goal, update the x scale (which will require a function we haven't introduced in lectures or labs yet!).\n\n![](https://sta199-s24.github.io/images/population-summary-lollipop.png)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(population_summary, aes()) +\n  geom_point(aes(x = total_pop, y = continent)) +\n  geom_segment(aes(y = continent, yend = continent, x = 0, xend = total_pop)) +\n  scale_x_continuous(labels = label_number(scale = 1/1000000, suffix = \" bil\")) +\n  theme_minimal() +\n  labs(\n    x = \"Total population\",\n    y = \"Continent\",\n    title = \"World population\",\n    subtitle = \"As of 2022\",\n    caption = \"Data sources: The World Bank and Our World in Data\"\n  )\n```\n\n::: {.cell-output-display}\n![](ae-06-population-joining-A_files/figure-html/population-summary-lollipop-1.png){width=672}\n:::\n:::\n\n\n-   **Think out loud:** What additional improvements would you like to make to this plot.\n\nAnswers may vary.\nOrdering the continents in decreasing order of population.\n",
    "supporting": [
      "ae-06-population-joining-A_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}